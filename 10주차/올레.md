# 10주차 Concurrency


## 여러 곳에서 접근하는 데이터에 대한 접근은 synchronize 시켜라
변수 레벨에서 atomic함은 java language가 보증하고 있다.
```
While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another.   
```
-> 그러면 왜 volatile 키워드가 필요한 건지?


### 무한 루프를 도는 예시 #1      
```
class Scratch {
    // Broken! - How long would you expect this program to run?
    private static boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested) {
                i++;
            }
            System.out.println("while문 끝!!!!!!!");
        });
        backgroundThread.start();
        TimeUnit.SECONDS.sleep(1);
        System.out.println("끝!!!!!!!!!!!!!!!!!!!!");
        stopRequested = true;
    }
}
```
위 코드를 실행하면,   
"끝!!!!!!!!!!!!!!!!!!!!"이 출력된 이후로도 실행이 멈추지 않는다(무한 루프).
i++을 실행하는 쓰레드가 바라보는 stopRequested에 main 쓰레드 변경사항이(stopRequested = true) 전파가 되지 않아서, while 루프가 끝나지 않기 때문이다.

### 예시 #2   
예시 #1의 while 루프에서 사용하는 변수에 volatile 변수를 추가한다.
이 예시에서는 무한루프가 끝난다.

```
class Scratch {
    // Broken! - How long would you expect this program to run?
    private static boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested) {
                i++;
            }
            System.out.println("while문 끝!!!!!!!");
        });
        backgroundThread.start();
        TimeUnit.SECONDS.sleep(1);
        System.out.println("끝!!!!!!!!!!!!!!!!!!!!");
        stopRequested = true;
    }
}
```
무한 루프를 타지 않는데, 그 이유는 i++를 실행하는 쓰레드에서 메인 쓰레드 변경값(stopRequested = true)를 읽을 수 있기 때문이다.
코드를 실행하면   
끝!!!!!!!!!!!!!!!!!!!!   
while문 끝!!!!!!!    
이 출력된다.

### 의문점
다음 코드를 실행하면, 프로그램이 정상 종료된다.

```
class Scratch {
    private static boolean stopRequested;
    private static Boolean hello = false;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested) {
                i++;
                synchronize();
            }
            System.out.println("while문 끝!!!!!!!" + Thread.currentThread().getName());
        });
        backgroundThread.start();
        TimeUnit.SECONDS.sleep(1);
        System.out.println("끝!!!!!!!!!!!!!!!!!!!!" + Thread.currentThread().getName());
        stopRequested = true;
    }

    public synchronized static void synchronize() {
        synchronized (hello) {
        }
    }
}
```
위 코드를 실행하면,
끝!!!!!!!!!!!!!!!!!!!!main   
while문 끝!!!!!!!Thread-2이 출력된 이후 프로그램이 정상 종료된다.
syncrhonize()를 호출하기만 해도, Thread-2와 main 쓰레드 간에 stopRequested의 상태가 공유된다.

synchronize의 범위는 hello까지인데, 왜 관련없는 stopRequested까지 같이 상태가 공유되는 걸까?



## synchronization 사용할 때 주의할 것들
1. syncrhonized 블록 안에서 잘 모르는 client의 메서드를 실행하지 말 것
2. performance를 고려하라. syncrhonized 키워드를 사용함으로써 시간이 오래 걸릴 수도 있다. 
  
